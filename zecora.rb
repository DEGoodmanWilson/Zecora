require 'grape'
require 'logger'
require 'json'
require 'openssl'
require 'octokit'
require 'jwt'
require 'time' # This is necessary to get the ISO 8601 representation of a Time object

module Zecora
  class API < Grape::API
    format :json

    # Never, ever, hardcode app tokens or other secrets in your code!
    # Always extract from a runtime source, like an environment variable.

    # Notice that the private key must be in PEM format, but the newlines should
    # be stripped and replaced with the literal `\n`. This can be done in the
    # terminal as such:
    # export GITHUB_PRIVATE_KEY=`awk '{printf "%s\\n", $0}' private-key.pem`
    PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n")) # convert newlines

    # You set the webhook secret when you create your app. This verifies that the
    # webhook is really coming from GH.
    WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

    # Get the app identifier—an integer—from your app page after you create your
    # app. This isn't actually a secret,
    # but it is something easier to configure at runtime.
    APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

    # Get our MongoDB url and credentials. Why did I choose MongoDB? Because it's the devil I know.
    MONGODB_URL = ENV['MONGODB_URL']

    ########## Before each request to our app
    #
    # Before each request to our app, we want to do two things
    # 1) Verify that this request actually came from GitHub by validating the
    # attached signature
    # 2) Create a new  Octokit client. Doing so requires that we construct a JWT.
    # https://jwt.io/introduction/
    # We have to also sign that JWT with our private key, so GitHub can be sure that
    #  a) it came from us
    #  b) it hasn't been altered by a malicious third party
    #
    before do
      request.body.rewind
      payload_raw = request.body.read # We need the raw text of the body to check
      # the webhook signature
      begin
        @payload = JSON.parse payload_raw
      rescue
        error!('401 Unauthorized', 401)
      end

      # Check X-Hub-Signature to confirm that this webhook was generated by
      # GitHub, and not a malicious third party. The way this works is: We have
      # registered with GitHub a secret, and we have stored it locally in
      # WEBHOOK_SECRET. GitHub will cryptographically sign the request payload
      # with this secret. We will do the same, and if the results match, then we
      # know that the request is from GitHub (or, at least, from someone who knows
      # the secret!) If they don't match, this request is an attack, and we should
      # reject it. The signature comes in with header x-hub-signature, and looks
      # like "sha1=123456" We should take the left hand side as the signature
      # method, and the right hand side as the HMAC digest (the signature) itself.
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, payload_raw)
      error!('401 Unauthorized', 401) unless their_digest == our_digest


      #---------------------
      # OK, so this request came from GitHub. Great.
      # Now, construct a JWT and use that to authenticate a new Client object

      jwt_payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # How long is the JWT good for (in seconds)?
          # Let's say it can be used for 10 minutes before it needs to be refreshed.
          # TODO we don't actually cache this token, we regenerate a new one every time!
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number, so GitHub knows who issued the JWT, and know what permissions
          # this token has.
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT
      jwt = JWT.encode(jwt_payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      # Notice that this client will _not_ have sufficient permissions to do many interesting things!
      # We might, for particular endpoints, need to generate an installation token (using the JWT), and instantiate
      # a new client object. But we'll cross that bridge when/if we get there!
      @app_client ||= Octokit::Client.new(bearer_token: jwt)


      # Now that we have an authenticated client, we need to authenticate against the installation that is
      # triggering this event
      unless @payload['installation'].nil? || @payload['installation']['id'].nil?
        installation_id ||= @payload['installation']['id']

        # the following line throws on uninstall! There won't be an installation token.
        begin
        installation_token = @app_client.create_app_installation_access_token(installation_id)[:token]
        @client ||= Octokit::Client.new(bearer_token: installation_token)
        rescue Octokit::NotFound
          @client = nil # we are probably being uninstalled.
        end
      end

      @event = headers['HTTP_X_GITHUB_EVENT']
    end

    ########## Helpers
    #
    # These functions are going to help us do some tasks that we don't want clogging up the happy paths above, or
    # that need to be done repeatedly. You can add anything you like here, really!
    #

    helpers do

      def delete_installation()
        # We were installed on a wrapper repo, but now we have been removed. Forget about this repo
        puts 'delete_installation'

      end

      def create_installation()
        # A new repo has installed us, yay! See if it's a wrapper repo, and if so, remember it and its details
        puts 'create installation'
      end

      def update_installation()
        # A wrapper repo that we're installed into has pushed up new code. There is a chance that they have
        # updated their Zecora configuration. If so, update our memory of that repo's settings.

      end

      ######

      def create_release()
        # The watched repo has—maybe—made a new release! We need to check if this really is a new release,
        # and if it is, create a new testing branch in the wrapper repo

        # TODO this is the super tricky part!
        # First, open `conanfile.py` and update the release number. In MOST cases, it will be on a line like
        # `    version = "0.9.51"`
        # In the remainder of the cases where it isn't—well, I'd like to know about them.
        # We'll also need to find any lines that reference `version` or that hard-code a version,
        # and bump them
        # We'll _also_ want to look for any _other_ references to the version number and bump those.
        # This will require knowing what the previous version we are bumping _from_ is, to achieve
        # this effeciently

        # Second, create that new branch.

        # Look to the version bump script in Luna for inspiration
      end

    end

    ########## Events
    #
    # This is the webhook endpoint that GH will call with events, and hence where we will do our event handling
    #

    desc 'Receive GitHub webhooks.'
    post ':events' do
      # What kind of event?
      # Installation event—persist app details, and subscribe to public feed of target library repository
      # New [tag|branch] on taget library repository: Dig up what is watching it, and create a new testing branch, and notify
      # puts request.env
      puts request.env['HTTP_X_GITHUB_EVENT']

      case request.env['HTTP_X_GITHUB_EVENT']
      when 'installation'
        case @payload['action']
        when 'deleted'
          delete_installation
        when 'created'
          create_installation
          # ALso need to update this information on any push to the main branch on the wrapper repo!
        end

        ## Events on watched repos
      when 'create'
        create_release
      end

      'ok'
    end

  end
end