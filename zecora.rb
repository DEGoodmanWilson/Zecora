require 'grape'
require 'logger'
require 'json'
require 'openssl'
require 'octokit'
require 'jwt'
require 'time' # This is necessary to get the ISO 8601 representation of a Time object
require 'base64'
require 'mongo'


module Zecora
  class API < Grape::API
    format :json

    # Never, ever, hardcode app tokens or other secrets in your code!
    # Always extract from a runtime source, like an environment variable.

    # Notice that the private key must be in PEM format, but the newlines should
    # be stripped and replaced with the literal `\n`. This can be done in the
    # terminal as such:
    # export GITHUB_PRIVATE_KEY=`awk '{printf "%s\\n", $0}' private-key.pem`
    PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n")) # convert newlines

    # You set the webhook secret when you create your app. This verifies that the
    # webhook is really coming from GH.
    WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

    # Get the app identifier—an integer—from your app page after you create your
    # app. This isn't actually a secret,
    # but it is something easier to configure at runtime.
    APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

    # Get our MongoDB url and credentials. Why did I choose MongoDB? Because it's the devil I know.
    MONGODB_URL = ENV['MONGODB_URL']

    MONGODB = Mongo::Client.new(MONGODB_URL)

    ########## Before each request to our app
    #
    # Before each request to our app, we want to do two things
    # 1) Verify that this request actually came from GitHub by validating the
    # attached signature
    # 2) Create a new  Octokit client. Doing so requires that we construct a JWT.
    # https://jwt.io/introduction/
    # We have to also sign that JWT with our private key, so GitHub can be sure that
    #  a) it came from us
    #  b) it hasn't been altered by a malicious third party
    #
    before do
      request.body.rewind
      payload_raw = request.body.read # We need the raw text of the body to check
      # the webhook signature
      begin
        @payload = JSON.parse payload_raw
      rescue
        error!('401 Unauthorized', 401)
      end

      # Check X-Hub-Signature to confirm that this webhook was generated by
      # GitHub, and not a malicious third party. The way this works is: We have
      # registered with GitHub a secret, and we have stored it locally in
      # WEBHOOK_SECRET. GitHub will cryptographically sign the request payload
      # with this secret. We will do the same, and if the results match, then we
      # know that the request is from GitHub (or, at least, from someone who knows
      # the secret!) If they don't match, this request is an attack, and we should
      # reject it. The signature comes in with header x-hub-signature, and looks
      # like "sha1=123456" We should take the left hand side as the signature
      # method, and the right hand side as the HMAC digest (the signature) itself.
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, payload_raw)
      error!('401 Unauthorized', 401) unless their_digest == our_digest


      #---------------------
      # OK, so this request came from GitHub. Great.
      # Now, construct a JWT and use that to authenticate a new Client object

      jwt_payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # How long is the JWT good for (in seconds)?
          # Let's say it can be used for 10 minutes before it needs to be refreshed.
          # TODO we don't actually cache this token, we regenerate a new one every time!
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number, so GitHub knows who issued the JWT, and know what permissions
          # this token has.
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT
      jwt = JWT.encode(jwt_payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      # Notice that this client will _not_ have sufficient permissions to do many interesting things!
      # We might, for particular endpoints, need to generate an installation token (using the JWT), and instantiate
      # a new client object. But we'll cross that bridge when/if we get there!
      @app_client ||= Octokit::Client.new(bearer_token: jwt)


      # Now that we have an authenticated client, we need to authenticate against the installation that is
      # triggering this event
      unless @payload['installation'].nil? || @payload['installation']['id'].nil?
        installation_id ||= @payload['installation']['id']

        # the following line throws on uninstall! There won't be an installation token.
        begin
          installation_token = @app_client.create_app_installation_access_token(installation_id)[:token]
          @client ||= Octokit::Client.new(bearer_token: installation_token)
        rescue Octokit::NotFound
          @client = nil # we are probably being uninstalled.
        end
      end

      @event = headers['HTTP_X_GITHUB_EVENT']

      @mongo_collection = MONGODB[:zecora]
    end

    ########## Helpers
    #
    # These functions are going to help us do some tasks that we don't want clogging up the happy paths above, or
    # that need to be done repeatedly. You can add anything you like here, really!
    #

    helpers do

      def delete_installation(reponame)
        # We were installed on a wrapper repo, but now we have been removed. Forget about this repo
        puts 'delete_installation'
        @mongo_collection.delete_one({installation_repo: reponame})

        # TODO check to see if we need to unsubscribe to the target repo

      end

      def delete_installations()
        puts 'delete installations'

        @mongo_collection.delete_many({installation_id: @payload['installation']['id']})

        # TODO figure out if we need to unsubscribe to any target repos

      end

      def create_installation(reponame)
        # look for a file called .zecora.json
        begin
          response = @client.contents(reponame, :path => '.zecora.json')
        rescue Octokit::NotFound
          # TODO no `.zecora.json` found. We'll just check each push to see if a .zecora.json is added later.
          return
        end
        zecora_conf = JSON.parse(Base64.decode64(response['content']))
        zecora_conf['installation_id'] = @payload['installation']['id']
        zecora_conf['installation_repo'] = reponame
        puts zecora_conf
        # TODO schema testing on the results!

        # Save the contents in a DB
        @mongo_collection.update_one({installation_repo: reponame}, zecora_conf, {upsert: true})

        # start listening to target repo using GitHub PubSubHubbub https://developer.github.com/v3/repos/hooks/#pubsubhubbub
      end

      ######

      def create_release()
        # The watched repo has—maybe—made a new release! We need to check if this really is a new release,
        # and if it is, create a new testing branch in the wrapper repo

        # TODO this is the super tricky part!
        # First, open `conanfile.py` and update the release number. In MOST cases, it will be on a line like
        # `    version = "0.9.51"`
        # In the remainder of the cases where it isn't—well, I'd like to know about them.
        # We'll also need to find any lines that reference `version` or that hard-code a version,
        # and bump them
        # We'll _also_ want to look for any _other_ references to the version number and bump those.
        # This will require knowing what the previous version we are bumping _from_ is, to achieve
        # this effeciently

        # Second, create that new branch.

        # Look to the version bump script in Luna for inspiration
      end

    end

    ########## Events
    #
    # This is the webhook endpoint that GH will call with events, and hence where we will do our event handling
    #

    desc 'Receive GitHub webhooks.'
    post ':events' do
      # What kind of event?
      # Installation event—persist app details, and subscribe to public feed of target library repository
      # New [tag|branch] on taget library repository: Dig up what is watching it, and create a new testing branch, and notify
      # puts request.env
      puts request.env['HTTP_X_GITHUB_EVENT']

      case request.env['HTTP_X_GITHUB_EVENT']
      when 'installation'
        case @payload['action']
        when 'deleted'
          delete_installations
        when 'created'
          @payload['repositories'].each do |repo|
            create_installation repo['full_name']
          end
          # ALso need to update this information on any push to the main branch on the wrapper repo!
        end

      when 'installation_repositories'
        # a new repo has been added or removed from an existing installation
        case @payload['action']
        when 'added'
          @payload['repositories_added'].each do |repo|
            create_installation repo['full_name']
          end
        when 'removed'
          @payload['repositories_removed'].each do |repo|
            delete_installation repo['full_name']
          end
        end

      when 'create'
        ## Events on watched repos
        create_installation # this function upserts :D

      end


      'ok'
    end

  end
end