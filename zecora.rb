require 'grape'
require 'logger'
require 'json'
require 'openssl'
require 'octokit'
require 'jwt'
require 'time' # This is necessary to get the ISO 8601 representation of a Time object

module Zecora
  class API < Grape::API
    format :json

    # Never, ever, hardcode app tokens or other secrets in your code!
    # Always extract from a runtime source, like an environment variable.

    # Notice that the private key must be in PEM format, but the newlines should
    # be stripped and replaced with the literal `\n`. This can be done in the
    # terminal as such:
    # export GITHUB_PRIVATE_KEY=`awk '{printf "%s\\n", $0}' private-key.pem`
    PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n")) # convert newlines

    # You set the webhook secret when you create your app. This verifies that the
    # webhook is really coming from GH.
    WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

    # Get the app identifier—an integer—from your app page after you create your
    # app. This isn't actually a secret,
    # but it is something easier to configure at runtime.
    APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

    RECASTAI_TOKEN = ENV['RECASTAI_TOKEN']

    ########## Before each request to our app
    #
    # Before each request to our app, we want to do two things
    # 1) Verify that this request actually came from GitHub by validating the
    # attached signature
    # 2) Create a new  Octokit client. Doing so requires that we construct a JWT.
    # https://jwt.io/introduction/
    # We have to also sign that JWT with our private key, so GitHub can be sure that
    #  a) it came from us
    #  b) it hasn't been altered by a malicious third party
    #
    before do
      request.body.rewind
      payload_raw = request.body.read # We need the raw text of the body to check
      # the webhook signature
      begin
        @payload = JSON.parse payload_raw
      rescue
        error!('401 Unauthorized', 401)
      end

      # Check X-Hub-Signature to confirm that this webhook was generated by
      # GitHub, and not a malicious third party. The way this works is: We have
      # registered with GitHub a secret, and we have stored it locally in
      # WEBHOOK_SECRET. GitHub will cryptographically sign the request payload
      # with this secret. We will do the same, and if the results match, then we
      # know that the request is from GitHub (or, at least, from someone who knows
      # the secret!) If they don't match, this request is an attack, and we should
      # reject it. The signature comes in with header x-hub-signature, and looks
      # like "sha1=123456" We should take the left hand side as the signature
      # method, and the right hand side as the HMAC digest (the signature) itself.
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, payload_raw)
      error!('401 Unauthorized', 401) unless their_digest == our_digest


      #---------------------
      # OK, so this request came from GitHub. Great.
      # Now, construct a JWT and use that to authenticate a new Client object

      jwt_payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # How long is the JWT good for (in seconds)?
          # Let's say it can be used for 10 minutes before it needs to be refreshed.
          # TODO we don't actually cache this token, we regenerate a new one every time!
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number, so GitHub knows who issued the JWT, and know what permissions
          # this token has.
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT
      jwt = JWT.encode(jwt_payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      # Notice that this client will _not_ have sufficient permissions to do many interesting things!
      # We might, for particular endpoints, need to generate an installation token (using the JWT), and instantiate
      # a new client object. But we'll cross that bridge when/if we get there!
      @app_client ||= Octokit::Client.new(bearer_token: jwt)


      # Now that we have an authenticated client, we need to authenticate against the installation that is
      # triggering this event
      unless @payload['installation'].nil? || @payload['installation']['id'].nil?
        installation_id ||= @payload['installation']['id']
        installation_token = @app_client.create_app_installation_access_token(installation_id)[:token]
        @client ||= Octokit::Client.new(bearer_token: installation_token)
      end

      @event = headers['HTTP_X_GITHUB_EVENT']
    end

    helpers do

    end

    desc 'Receive GitHub webhooks.'
    post ':events' do
      authenticate!
      'ok'
    end

  end
end